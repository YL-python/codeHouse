# 16年省赛真题笔记

### 第一题：煤球数目

#### 问题

有一堆煤球，堆成三角棱锥形。具体：
第一层放1个，
第二层3个（排列成三角形），
第三层6个（排列成三角形），
第四层10个（排列成三角形），
....
如果一共有100层，共有多少个煤球？

#### 代码

```c++
#include<cstdio>
int main() {
	int now=0,ans=0,temp=1;
	for(int i=1; i<=100; i++) {
		now += temp;
		temp ++ ;
		ans += now;
	}
	printf("%d",ans);
	return 0;
}
```

#### 笔记

+ 文字游戏，100层问一共多少注意不是第一百层有多少

### 第二题：生日蜡烛

#### 问题

某君从某年开始每年都举办一次生日party，并且每次都要吹熄与年龄相同根数的蜡烛。

现在算起来，他一共吹熄了236根蜡烛。

请问，他从多少岁开始过生日party的？

#### 代码

```c++
#include<cstdio>
int main() {
	for(int i=0; i<=150; i++) {
		int temp = i,sum = 0;
		while(sum < 236) {
			sum+=temp;
			temp++;
		}
		if(sum == 236) {
			printf("%d到%d岁之间一共吹了236根蜡烛",i,temp-1);
		}
	}
	return 0;
}
```

#### 笔记

+ 暴力

### 第三题：凑算式

#### 问题 

```c++
     B      DEF
A + --- + ------- = 10
     C      GHI
```

这个算式中A~I 代表 1~9的数字，不同的字母代表不同的数字。

比如：
6+8/3+952/714 就是一种解法，
5+3/1+972/486 是另一种解法。

这个算式一共有多少种解法？

#### 代码

```c++
#include<cstdio>
int a[] = {1,2,3,4,5,6,7,8,9},ans;
bool check() {
	int x = a[3] * 100 + a[4] * 10 + a[5];
	int y = a[6] * 100 + a[7] * 10 + a[8];
	if((a[1] * y + a[2] * x) % (y * a[2]) == 0 && a[0] + (a[1] * y + a[2] * x) / (y * a[2]) == 10)return true;
	return false;
}
// 递归回溯生成全排列  适用于无重复元素的情况
void f(int k) {
	if(k == 9) {
		if(check()) ans++;
	}
	// 从第k位开始 把数组的每一项都放在 k位上尝试
	for(int i=k; i<9; i++) {
		{ int t=a[i]; a[i]=a[k]; a[k]=t; }
		f(k+1);  // 递归
		{ int t=a[i]; a[i]=a[k]; a[k]=t; }  // 回溯
	}
}
int main() {
	//	f(0);
	do{
		if(check()) ans++;
	}while(next_permutation(a,a+9));
	printf("%d\n",ans);
	return 0;
}
```

#### 笔记

+ 第一个坑是分式同分之后在计算，样例一 的 8/3 就是一个无尽小数
+ next_permutation 需要元素不重复并且有序

### 第四题：快速排序

#### 问题

排序在各种场合经常被用到。
快速排序是十分常用的高效率的算法。

其思想是：先选一个“标尺”，
用它把整个队列过一遍筛子，
以保证：其左边的元素都不大于它，其右边的元素都不小于它。

这样，排序问题就被分割为两个子区间。
再分别对子区间排序就可以了。

下面的代码是一种实现，请分析并填写划线部分缺少的代码。

```c
#include <stdio.h>

void swap(int a[], int i, int j)
{
	int t = a[i];
	a[i] = a[j];
	a[j] = t;
}

int partition(int a[], int p, int r)
{
    int i = p;
    int j = r + 1;
    int x = a[p];
    while(1){
        while(i<r && a[++i]<x);
        while(a[--j]>x);
        if(i>=j) break;
        swap(a,i,j);
    }
	______________________; // swap(a,p,j);
    return j;
}

void quicksort(int a[], int p, int r)
{
    if(p<r){
        int q = partition(a,p,r);
        quicksort(a,p,q-1);
        quicksort(a,q+1,r);
    }
}
    
int main()
{
	int i;
	int a[] = {5,13,6,24,2,8,19,27,6,12,1,17};
	int N = 12;
	
	quicksort(a, 0, N-1);
	
	for(i=0; i<N; i++) printf("%d ", a[i]);
	printf("\n");
	
	return 0;
}
```

#### 笔记

+ 需要读一下代码，一开始是把第一个元素作为标尺，然后双指针找大于和小于第一个元素的下标，最后交换，在代码的最后是第一个元素不动，之后的元素就是以第一个元素位分界，左边全小于他右边全大于他，所以最后一步需要把第一个元素放到中间去

### 第五题：抽签

#### 问题

X星球要派出一个5人组成的观察团前往W星。
其中：
A国最多可以派出4人。
B国最多可以派出2人。
C国最多可以派出2人。
....

那么最终派往W星的观察团会有多少种国别的不同组合呢？

下面的程序解决了这个问题。
数组a[] 中既是每个国家可以派出的最多的名额。
程序执行结果为：
DEFFF
CEFFF
CDFFF
CDEFF
CCFFF
CCEFF
CCDFF
CCDEF
BEFFF
BDFFF
BDEFF
BCFFF
BCEFF
BCDFF
BCDEF
....
(以下省略，总共101行)

```c++
#include <stdio.h>
#define N 6
#define M 5
#define BUF 1024

void f(int a[], int k, int m, char b[]) {
	int i,j;

	if(k==N) {
		b[M] = 0;
		if(m==0) printf("%s\n",b);
		return;
	}

	for(i=0; i<=a[k]; i++) {
		for(j=0; j<i; j++) b[M-m+j] = k+'A';
		______________________;  // f(a,k+1,m-i,b);
	}
}
int main() {
	int  a[N] = {4,2,2,1,1,3};
	char b[BUF];
	f(a,0,M,b);
	return 0;
}
```

#### 笔记

+ 搞懂每一个参数的含义就行
+ k是第几个国家
+ m是已经派出了多少人

### 第六题：方格填数

#### 问题

如下的10个格子

```
   +--+--+--+
   |  |  |  |
+--+--+--+--+
|  |  |  |  |
+--+--+--+--+
|  |  |  |
+--+--+--+
```

填入0~9的数字。要求：连续的两个数字不能相邻。
（左右、上下、对角都算相邻）

一共有多少种可能的填数方案？

#### 代码

```c++
#include <cstdio>
#include <cmath>
int a[] = {0,1,2,3,4,5,6,7,8,9},ans;

bool check() {
	if( abs(a[0] - a[1]) == 1||
	    abs(a[0] - a[3]) == 1||
	    abs(a[0] - a[4]) == 1||
	    abs(a[0] - a[5]) == 1||

	    abs(a[1] - a[2]) == 1||
	    abs(a[1] - a[4]) == 1||
	    abs(a[1] - a[5]) == 1||
	    abs(a[1] - a[6]) == 1||

	    abs(a[2] - a[5]) == 1||
	    abs(a[2] - a[6]) == 1||

	    abs(a[3] - a[4]) == 1||
	    abs(a[3] - a[7]) == 1||
	    abs(a[3] - a[8]) == 1||

	    abs(a[4] - a[5]) == 1||
	    abs(a[4] - a[7]) == 1||
	    abs(a[4] - a[9]) == 1||
	    abs(a[4] - a[8]) == 1||

	    abs(a[5] - a[6]) == 1||
	    abs(a[5] - a[9]) == 1||
	    abs(a[5] - a[8]) == 1||

	    abs(a[6] - a[9]) == 1||
	    abs(a[7] - a[8]) == 1||
	    abs(a[8] - a[9]) == 1	)
		return false;
	return true;
}

void f(int k) {
	if(k == 10) {
		if(check())
			ans++;
	}
	for(int i=k; i<10; i++) {
		{ int t=a[i]; a[i]=a[k]; a[k]=t; }
		f(k+1);
		{ int t=a[i]; a[i]=a[k]; a[k]=t; }
	}
}

int main() {
	f(0);
	printf("%d\n",ans);
	return 0;
}
```

#### 笔记

+ 全排列加check  难度不大

### 第七题：剪邮票

#### 问题

如【图1.jpg】, 有12张连在一起的12生肖的邮票。现在你要从中剪下5张来，要求必须是连着的。

![图1](16%E5%B9%B4%E7%9C%81%E8%B5%9B%E7%9C%9F%E9%A2%98%E7%AC%94%E8%AE%B0.assets/%E5%9B%BE1.jpg)

（仅仅连接一个角不算相连）
比如，【图2.jpg】，【图3.jpg】中，粉红色所示部分就是合格的剪取。

![图2](16%E5%B9%B4%E7%9C%81%E8%B5%9B%E7%9C%9F%E9%A2%98%E7%AC%94%E8%AE%B0.assets/%E5%9B%BE2.jpg)

![图3](16%E5%B9%B4%E7%9C%81%E8%B5%9B%E7%9C%9F%E9%A2%98%E7%AC%94%E8%AE%B0.assets/%E5%9B%BE3.jpg)

请你计算，一共有多少种不同的剪取方法。

#### 代码

```c++
#include <cstdio>
#include <algorithm>
using namespace std;
int a[] = {0,0,0,0,0,0,0,1,1,1,1,1},ans;

void dfs(int g[3][4],int i,int j) {
	g[i][j] = 0;
	if(i-1 >= 0 && g[i-1][j] == 1) dfs(g,i-1,j);
	if(i+1 <= 2 && g[i+1][j] == 1) dfs(g,i+1,j);
	if(j-1 >= 0 && g[i][j-1] == 1) dfs(g,i,j-1);
	if(j+1 <= 3 && g[i][j+1] == 1) dfs(g,i,j+1);
}

bool check() {
	int g[3][4];
	// 一维转二维
	for(int i=0; i<3; i++) {
		for(int j=0; j<4; j++) {
			if(a[i*4+j] == 1) g[i][j] = 1;
			else g[i][j] = 0;
		}
	}
	// 对 g 做连通性检测
	int cnt = 0;  // 连通块的个数
	for(int i=0; i<3; i++) {
		for(int j=0; j<4; j++) {
			if(g[i][j] == 1) {
				dfs(g,i,j);
				cnt++;
			}
		}
	}
	return cnt == 1;
}

int main() {
	do {
		if(check()) {
			ans++;
		}
	} while(next_permutation(a,a+12));
	printf("%d\n",ans);
	return 0;
}
```

#### 笔记

+ DFS做连通块检测 看看有多少连通块
+ 全排列，有重复元素的全排列，有重复元素全排列去重，有重复元素全排列不去重。
+ 这个题用全排列，转二维数组，去重，连通性检测。

### 第八题：四平方和

#### 问题

四平方和定理，又称为拉格朗日定理：
每个正整数都可以表示为至多4个正整数的平方和。
如果把0包括进去，就正好可以表示为4个数的平方和。

比如：
5 = 0^2 + 0^2 + 1^2 + 2^2
7 = 1^2 + 1^2 + 1^2 + 2^2
（^符号表示乘方的意思）

对于一个给定的正整数，可能存在多种平方和的表示法。
要求你对4个数排序：
0 <= a <= b <= c <= d
并对所有的可能表示法按 a,b,c,d 为联合主键升序排列，最后输出第一个表示法


程序输入为一个正整数N (N<5000000)
要求输出4个非负整数，按从小到大排序，中间用空格分开

例如，输入：
5
则程序应该输出：
0 0 1 2

再例如，输入：
12
则程序应该输出：
0 2 2 2

#### 代码

```c++
#include <iostream>
#include <cmath>
#include <map>
using namespace std;
int n;
map<int,int> cache;
int main() {
	cin >> n;
	for(int c=0; c*c <= n/2; c++) {
		for(int d=c; c*c + d*d <= n; d++) {
			if(cache.find(c*c + d*d) == cache.end())
				cache[c*c + d*d] = c;
		}
	}
	for(int a=0; a*a <= n/4; a++) {
		for(int b=a; a*a + b*b <= n/3; b++) {
			if(cache.find(n - a*a - b*b) != cache.end()) {
				int c = cache[n - a*a - b*b];
				int d = int(sqrt(n - a*a - b*b - c*c));
				cout << a << " "<< b << " "<< c << " "<< d << endl;
				return 0;
			}
		}
	}
	return 0;
}
```

#### 笔记

+ 四层循坏暴力解回超时
+ 就用一个哈希表缓存后二层的所有结果，在暴力前二层的时候进行判断操作
+ 空间换时间
+ 缓存表的时候键值关系很特殊

### 第九题：交换瓶子

#### 问题

有N个瓶子，编号 1 ~ N，放在架子上。

比如有5个瓶子：
2 1 3 5 4

要求每次拿起2个瓶子，交换它们的位置。
经过若干次后，使得瓶子的序号为：
1 2 3 4 5

对于这么简单的情况，显然，至少需要交换2次就可以复位。

如果瓶子更多呢？你可以通过编程来解决。

输入格式为两行：
第一行: 一个正整数N（N<10000）, 表示瓶子的数目
第二行：N个正整数，用空格分开，表示瓶子目前的排列情况。

输出数据为一行一个正整数，表示至少交换多少次，才能完成排序。

例如，输入：
5
3 1 2 5 4

程序应该输出：
3

再例如，输入：
5
5 4 3 2 1

程序应该输出：
2

#### 代码

```c++
#include<iostream>
using namespace std;
int n,a[10005],ans;

int pos(int x) {
	for(int i=1; i<=n; i++) {
		if(a[i] == x)
			return i;
	}
}
void swap(int i,int j) {
	int t = a[i];
	a[i] = a[j];
	a[j] = t;
}

int main() {
	cin >> n;
	for(int i=1; i<=n; i++) {
		cin >> a[i];
	}
	for(int i=1; i<=n; i++) {
		if(a[i] == i) continue;
		else {
			swap(pos(i),i);
			ans++;
		}
	}
	cout << ans;
	return 0;
}
```

#### 笔记

+ 按常规思路来，不要把题目想的太复杂了

### 第十题：最大比例

#### 问题

X星球的某个大奖赛设了M级奖励。每个级别的奖金是一个正整数。
并且，相邻的两个级别间的比例是个固定值。
也就是说：所有级别的奖金数构成了一个等比数列。比如：
16,24,36,54
其等比值为：3/2

现在，我们随机调查了一些获奖者的奖金数。
请你据此推算可能的最大的等比值。

输入格式：
第一行为数字 N (0<N<100)，表示接下的一行包含N个正整数
第二行N个正整数Xi(Xi<1 000 000 000 000)，用空格分开。每个整数表示调查到的某人的奖金数额

要求输出：
一个形如A/B的分数，要求A、B互质。表示可能的最大比例系数

测试数据保证了输入格式正确，并且最大比例是存在的。

例如，输入：
3
1250 200 32

程序应该输出：
25/4

再例如，输入：
4
3125 32 32 200

程序应该输出：
5/2

再例如，输入：
3
549755813888 524288 2

程序应该输出：
4/1

#### 代码

```c++
#include <stdio.h>
#include <iostream>
#include <algorithm>
#include <vector>
#include <map>
using namespace std;
typedef long long LL;
int n;
LL data[100];

struct Ratio {
	LL x,y;
	Ratio(LL _x,LL _y):x(_x),y(_y) {
		LL _gcd = gcd(x,y);
		x/=_gcd;
		y/=_gcd;
	}
	LL gcd(LL a,LL b) {
		return b?gcd(b,a%b):a;
	}
};

vector<Ratio> ratio;
map<LL, map<LL,LL> > all_ex;
map<LL, map<LL,LL> > all_log;

void init() {
	for(int i=2; i<1e6; i++) {
		LL cur = (LL) i*i;
		int pow = 2;
		while(cur < 1e12) {
			all_ex[cur][pow] = i;
			all_log[cur][i] = pow;
			pow ++;
			cur*=i;
		}
	}
}

LL extract(LL x,LL pow) {
	if(pow == 1) return x;
	if(x == 1) return 1;
	if(all_ex[x].find(pow) != all_ex[x].end())
		return all_ex[x][pow];
	else
		return -1;
}
LL log(LL base,LL x) {
	if(base == x) return 1;
	if(all_log[x].find(base) != all_log[x].end())
		return all_log[x][base];
	else
		return -1;
}

int main() {
	init();
	scanf("%d",&n);
	for(int i=0; i<n; i++) {
		scanf("%lld",&data[i]);
	}
	sort(data,data+n);
	if(n == 2) {
		Ratio ans = Ratio(data[1],data[0]);
		printf("%lld/%lld",ans.x,ans.y);
		return 0;
	}
	// 求两两比值 用分数形式存储，存到 vector中
	for(int i=0; i<n-1; i++) {
		if(data[i+1] != data[i])
			ratio.push_back(Ratio(data[i+1],data[i]));
	}
	for(int pow=0; pow<41; pow++) {
		Ratio ra0 = ratio[0];
		LL x = ra0.x;
		LL y = ra0.y;
		LL base_x = extract(x,pow);  // x求 pow次方
		LL base_y = extract(y,pow);
		if(base_x == -1 || base_y == -1)continue;
		bool all_match = true;
		for(int i=1; i<ratio.size(); i++) {
			LL xx = ratio[i].x;
			LL yy = ratio[i].y;
			LL log_x = log(base_x,xx);  // x求 pow次方
			LL log_y = log(base_y,yy);
			if(log_x == -1 || log_y == -1 || log_x!=log_y) {
				all_match = false;
				break;
			}
		}
		if(all_match) {
			Ratio ans = Ratio(base_x,base_y);
			printf("%lld/%lld",ans.x,ans.y);
			return 0;
		}
	}
	return 0;
}
```

#### 笔记

+ 

