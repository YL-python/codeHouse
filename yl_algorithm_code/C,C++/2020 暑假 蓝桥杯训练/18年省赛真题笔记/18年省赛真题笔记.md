# 18年省赛真题笔记

### 第一题：第几天

#### 问题

2000年的1月1日，是那一年的第1天。那么，2000年的5月4日，是那一年的第几天？

#### 代码

```c++
#include <cstdio>
int main(){
	printf("%d",31+29+31+30+4); 
	return 0;
} 
```

#### 笔记

第一题比较简单，而且问的时间和起点时间相差比较小，可以直接口算，要注意的就是2000年是闰年，二月就是29天。

### 第二题：明码

#### 问题

汉字的字形存在于字库中，即便在今天，16点阵的字库也仍然使用广泛。16点阵的字库把每个汉字看成是16x16个像素信息。并把这些信息记录在字节中。一个字节可以存储8位信息，用32个字节就可以存一个汉字的字形了。把每个字节转为2进制表示，1表示墨迹，0表示底色。每行2个字节，一共16行，布局是：

第1字节，第2字节
第3字节，第4字节
....
第31字节, 第32字节

这道题目是给你一段多个汉字组成的信息，每个汉字用32个字节表示，这里给出了字节作为有符号整数的值。题目的要求隐藏在这些信息中。你的任务是复原这些汉字的字形，从中看出题目的要求，并根据要求填写答案。

这段信息是（一共10个汉字）：
4 0 4 0 4 0 4 32 -1 -16 4 32 4 32 4 32 4 32 4 32 8 32 8 32 16 34 16 34 32 30 -64 0 
16 64 16 64 34 68 127 126 66 -124 67 4 66 4 66 -124 126 100 66 36 66 4 66 4 66 4 126 4 66 40 0 16 
4 0 4 0 4 0 4 32 -1 -16 4 32 4 32 4 32 4 32 4 32 8 32 8 32 16 34 16 34 32 30 -64 0 
0 -128 64 -128 48 -128 17 8 1 -4 2 8 8 80 16 64 32 64 -32 64 32 -96 32 -96 33 16 34 8 36 14 40 4 
4 0 3 0 1 0 0 4 -1 -2 4 0 4 16 7 -8 4 16 4 16 4 16 8 16 8 16 16 16 32 -96 64 64 
16 64 20 72 62 -4 73 32 5 16 1 0 63 -8 1 0 -1 -2 0 64 0 80 63 -8 8 64 4 64 1 64 0 -128 
0 16 63 -8 1 0 1 0 1 0 1 4 -1 -2 1 0 1 0 1 0 1 0 1 0 1 0 1 0 5 0 2 0 
2 0 2 0 7 -16 8 32 24 64 37 -128 2 -128 12 -128 113 -4 2 8 12 16 18 32 33 -64 1 0 14 0 112 0 
1 0 1 0 1 0 9 32 9 16 17 12 17 4 33 16 65 16 1 32 1 64 0 -128 1 0 2 0 12 0 112 0 
0 0 0 0 7 -16 24 24 48 12 56 12 0 56 0 -32 0 -64 0 -128 0 0 0 0 1 -128 3 -64 1 -128 0 0 

#### 代码

```c++
#include <iostream>
using namespace std;

void toBinaryStr(int x) {
	string ans = "--------";
	if(x < 0) {
		ans[0] = '1';
		x = 128 + x;
	}
	for(int i=0; i<7; i++) {
		if( ((x >> i) & 1) == 1 ) {
			ans[8-i-1] = '1';
		}
	}
	cout << ans;
}

int main() {
	for(int i=0; i<10; i++) {
		for(int j=0; j<16; j++) {
			int x,y;
			cin >> x>> y;
			toBinaryStr(x);
			toBinaryStr(y);
			cout << endl;
		}
	}
	// 九的九次方是多少？
	int ans = 1;
	for(int i=0; i<9; i++)
		ans*=9;
	cout << ans << endl;
	return 0;
}
```

#### 笔记

+ 输入，一推数据直接复制黏贴输入就行。
+ 字符串还是字符串好用，char 数组用起来真难受
+ 求负数的二进制，正常是原，反，补码一套操作。

```c
求反码取巧操作
比如八位二进制 表示的范围就是 [-127,128]，第一位是符号位，所以就只有2的7次方256个数又要分成正负数。
负数 x 的二进制就是  第一位符号位为1  其余为等于 （128+x）这个数的二进制
```

+ 位运算和移位运算求二进制

```c
>> 右移位操作 移一位是 除2的1次方 移2位是除2的2次方。
& 与运算 二进制位挨个比较 同样的返回1 
& 与运算 一般是 & 1  就获得到这个数的二进制的最后一位了，最后一位是1就是奇数，是2就是偶数

所以求一个数二进制的每一个数可以用 这个数 右移位 然后 & 1 获取他的最后一位上的数值。挨个获取就能获取到所有位上的数值了。
```

### 第三题：乘积尾零

#### 问题

如下的10行数据，每行有10个整数，请你求出它们的乘积的末尾有多少个零？

5650 4542 3554 473 946 4114 3871 9073 90 4329 
2758 7949 6113 5659 5245 7432 3051 4434 6704 3594 
9937 1173 6866 3397 4759 7557 3070 2287 1453 9899 
1486 5722 3135 1170 4014 5510 5120 729 2880 9019 
2049 698 4582 4346 4427 646 9742 7340 1230 7683 
5693 7015 6887 7381 4172 4341 2909 2027 7355 5649 
6701 6645 1671 5978 2704 9926 295 3125 3878 6785 
2066 4247 4800 1578 6652 4616 1113 6205 3264 2915 
3966 5291 2904 1285 2193 1428 2265 8730 9436 7074 
689 5510 8243 6114 337 4096 8199 7313 3685 211 

#### 代码

```c++
#include <cstdio>

int cnt2,cnt5,temp,x;

int main() {
	for(int i=0; i<100; i++) {
		scanf("%d",&x);
		temp = x;
		while(temp % 2 == 0) {
			temp /= 2;
			cnt2++;
		}
		temp = x;
		while(temp % 5 == 0) {
			temp /= 5;
			cnt5++;
		}
	}
	int ans = cnt2<cnt5?cnt2:cnt5;
	printf("%d\n",ans);
	return 0;
}
```

#### 笔记

+ 尾数为 0 就只有 因子里面 有 5 才会出现0，所以就判断每一个数能分解出来多少个 5。
+ 还有就是2 的个数小于 5的话，最多的0就和2的个数有关。

### 第四题：测试次数

#### 问题

x星球的居民脾气不太好，但好在他们生气的时候唯一的异常举动是：摔手机。各大厂商也就纷纷推出各种耐摔型手机。x星球的质监局规定了手机必须经过耐摔测试，并且评定出一个耐摔指数来，之后才允许上市流通。x星球有很多高耸入云的高塔，刚好可以用来做耐摔测试。塔的每一层高度都是一样的，与地球上稍有不同的是，他们的第一层不是地面，而是相当于我们的2楼。

如果手机从第7层扔下去没摔坏，但第8层摔坏了，则手机耐摔指数=7。特别地，如果手机从第1层扔下去就坏了，则耐摔指数=0。如果到了塔的最高层第n层扔没摔坏，则耐摔指数=n

为了减少测试次数，从每个厂家抽样3部手机参加测试。某次测试的塔高为1000层，如果我们总是采用**最佳策略**，在**最坏的运气**下最多需要测试多少次才能确定手机的耐摔指数呢？

请填写这个最多测试次数。

#### 代码

```c++
#include <iostream>
#include <climits>
#include <cmath>
using namespace std;

const int N = 1000;
// f1 f2 f3 表示1 2 3部手机时第1成的最坏测试数
int f1[N+1],f2[N+1],f3[N+1];

int main() {
	// 只有一部手机的情况下，最坏测试情况只能是从第一层开始一个一个往上测试
	// 所以最坏的情况就是 i
	for(int i=1; i<=N; i++) {
		f1[i] = i;
	}

	// 两部手机的情况
	for(int i=1; i<=N; i++) {
		int ans = INT_MAX;
		for(int j=1; j<=i; j++) {
			// min 是最优策略  max是最坏情况
			// 在j层测试 摔坏就是 还要测试 f1[i-j]  没摔快就是 f2[j-1]
			ans = min(ans,1+max(f1[i-j],f2[j-1]));
		}
		f2[i] = ans;
	}
	// 三部手机的情况
	for(int i=1; i<=N; i++) {
		int ans = INT_MAX;
		for(int j=1; j<=i; j++) {
			ans = min(ans,1+max(f2[i-j],f3[j-1]));
		}
		f3[i] = ans;
	}
	printf("%d",f3[1000]);
	return 0;
}
```

#### 笔记

+ climits 这个头文件里面装了很多常见的常量
+ 两个变量决定一个值的时候就要考虑是不是可以dp做
+ 理清思路不要慌，从1 一点点枚举过去找思路

### 第五题：递增三元组

#### 问题

给定三个整数数组
A = [A1, A2, ... AN], 
B = [B1, B2, ... BN], 
C = [C1, C2, ... CN]，
请你统计有多少个三元组(i, j, k) 满足：
1. 1 <= i, j, k <= N  
2. Ai < Bj < Ck  

【输入格式】 
第一行包含一个整数N。
第二行包含N个整数A1, A2, ... AN。
第三行包含N个整数B1, B2, ... BN。
第四行包含N个整数C1, C2, ... CN。

对于30%的数据，1 <= N <= 100  
对于60%的数据，1 <= N <= 1000 
对于100%的数据，1 <= N <= 100000 0 <= Ai, Bi, Ci <= 100000 

【输出格式】
一个整数表示答案

【样例输入】
3
1 1 1
2 2 2
3 3 3

【样例输出】
27 

#### 代码

```c++
#include <iostream>
#include <algorithm>
using namespace std;

int n,p,q;
int a[100005],b[100005],c[100005];

int main() {
	cin >> n;
	for(int i=0; i<n; i++) {
		cin >> a[i];
	}
	for(int i=0; i<n; i++) {
		cin >> b[i];
	}
	for(int i=0; i<n; i++) {
		cin >> c[i];
	}
	sort(a,a+n);
	sort(b,b+n);
	sort(c,c+n);
	long long ans = 0;
	for(int i=0; i<n; i++) {
		while(p<n && a[p] < b[i]) p++;
		while(q<n && c[q] <= b[i]) q++;
		ans += (long long ) p*(n-q);
	}
	cout << ans;
	return 0;
}
```

#### 笔记

+ 难度其实也不大 不过直接暴力枚举的时候就会超时，所以我们用B数组作为基准，在a数组中找小于B的 在c中找大于B的，而且如果 b[i] > c[i] 那么 b[i+1] > c[i] 也是成立的，所以又可以不用每一次都从头找

### 第六题：螺旋折线

#### 问题

![1596698985255](18%E5%B9%B4%E7%9C%81%E8%B5%9B%E7%9C%9F%E9%A2%98%E7%AC%94%E8%AE%B0.assets/1596698985255.png)

如图所示的螺旋折线经过平面上所有整点恰好一次。  
对于整点(X, Y)，我们定义它到原点的距离dis(X, Y)是从原点到(X, Y)的螺旋折线段的长度。  

例如dis(0, 1)=3, dis(-2, -1)=9  

给出整点坐标(X, Y)，你能计算出dis(X, Y)吗？

【输入格式】
X和Y  

对于40%的数据，-1000 <= X, Y <= 1000  
对于70%的数据，-100000 <= X， Y <= 100000  
对于100%的数据, -1000000000 <= X, Y <= 1000000000  

【输出格式】
输出dis(X, Y)  


【样例输入】
0 1

【样例输出】
3

#### 代码

```c++

```

#### 笔记

### 第七题：日志统计

#### 问题

小明维护着一个程序员论坛。现在他收集了一份"点赞"日志，日志共有N行。其中每一行的格式是：

ts id  

表示在ts时刻编号id的帖子收到一个"赞"。  

现在小明想统计有哪些帖子曾经是"热帖"。如果一个帖子曾在任意一个长度为D的时间段内收到不少于K个赞，小明就认为这个帖子曾是"热帖"。  

具体来说，如果存在某个时刻T满足该帖在[T, T+D)这段时间内(注意是左闭右开区间)收到不少于K个赞，该帖就曾是"热帖"。  

给定日志，请你帮助小明统计出所有曾是"热帖"的帖子编号。  

【输入格式】
第一行包含三个整数N、D和K。  
以下N行每行一条日志，包含两个整数ts和id。  

对于50%的数据，1 <= K <= N <= 1000  
对于100%的数据，1 <= K <= N <= 100000 0 <= ts <= 100000 0 <= id <= 100000  

【输出格式】
按从小到大的顺序输出热帖id。每个id一行。  

【输入样例】
7 10 2  
0 1  
0 10    
10 10  
10 1  
9 1
100 3  
100 3  

【输出样例】
1  
3  

#### 代码

```c++
#include <iostream>
#include <vector>
#include <set>
#include <map>
#include <algorithm>
using namespace std;

struct R {
	int ts,id;
};

bool cmp (R r1,R r2) {
	return r1.ts < r2.ts;
}
int N,D,K;

int main() {
	cin >> N >> D >> K;
	vector<R> records(N);
	map<int, int> cnt;  // 记录 id和他出现的次数
	for(int i=0; i<N; i++) {
		cin >> records[i].ts >> records[i].id;
	}
	sort(records.begin(), records.end(), cmp);// 按照时间 对结构体自定义排序
	int j=0;  // 尺取法 探测指针
	set<int > ans; // 记录结果，自动去重和排序
	for(int i=0; i<N; i++) {  // i 是尺取法的起点
		while( j < N && records[j].ts - records[i].ts < D) {
			cnt[records[j].id] ++ ;  // 加加
			if(cnt[records[j].id] >= K) {
				ans.insert(records[j].id);
			}
			j++;
		}
		cnt[records[j].id] -- ;  // 减去多加的
	}
	for(set<int>::iterator i=ans.begin(); i!=ans.end(); i++) {
		cout << *i << endl;
	}
	return 0;
}
```

#### 笔记

+ 难度不大 ，各种数据结构的使用，结构体的排序，尺取法等等。

### 第八题：全球变暖

#### 问题

你有一张某海域NxN像素的照片，"."表示海洋、"#"表示陆地，如下所示：

.......
.##....
.##....
....##.
..####.
...###.
.......

其中"上下左右"四个方向上连在一起的一片陆地组成一座岛屿。例如上图就有2座岛屿。  

由于全球变暖导致了海面上升，科学家预测未来几十年，岛屿边缘一个像素的范围会被海水淹没。具体来说如果一块陆地像素与海洋相邻(上下左右四个相邻像素中有海洋)，它就会被淹没。  

例如上图中的海域未来会变成如下样子：

.......
.......
.......
.......
....#..
.......
.......

请你计算：依照科学家的预测，照片中有多少岛屿会被完全淹没。  

【输入格式】
第一行包含一个整数N。  (1 <= N <= 1000)  
以下N行N列代表一张海域照片。  

照片保证第1行、第1列、第N行、第N列的像素都是海洋。  

【输出格式】
一个整数表示答案。

【输入样例】
7 
.......
.##....
.##....
....##.
..####.
...###.
.......  

【输出样例】
1  

#### 代码

```c++
#include <cstdio>
#include <queue>
using namespace std;

char map[1005][1005];
int vis[1005][1005],n,ans;
int dx[] = {0,0,1,-1};
int dy[] = {1,-1,0,0};

struct Point {
	int x,y;
};

void bfs(int i,int j) {
	vis[i][j] = 1;  // 标记为访问过了
	queue<Point> q;  // 一个队列就是一块 
	q.push({i,j});
	int cnt1=0,cnt2=0; // 记录当前块 # 的数量 和 淹没的数量
	while(! q.empty()) {
		Point first = q.front();
		q.pop();
		cnt1++;  // # 号数量加一 
		bool swed = false;  // 记录这个块的 # 号周围是不是有 .
		for(int i=0; i<n; i++) {
			int x = first.x + dx[i];
			int y = first.y + dy[i];
			if(0<=x && x<n && 0<=y && y<n && map[x][y] == '.') {
				swed = true; // # 周围有 .
			}
			if(0<=x && x<n && 0<=y && y<n && map[x][y] == '#' && vis[x][y] == 0) {
				q.push({x,y});  // 吧周围的 # 号加如队列中并且标记访问
				vis[x][y] = 1;
			}
		}
		if(swed) cnt2++; // 淹没的数量加一
	}
	// #号和淹没的数量相等的时候这块岛屿就没了 
	if(cnt1 == cnt2) ans++;
}


int main() {
	scanf("%d",&n);
	for(int i=0; i<n; i++) {
		for(int j=0; j<n; j++) {
			scanf("%c",&map[i][j]);
		}
	}
	for(int i=0; i<n; i++) {
		for(int j=0; j<n; j++) {
			if(map[i][j] == '#' && vis[i][j] == 0) {
				bfs(i,j);
			}
		}
	}
	printf("%d",ans);
	return 0;
}
```

#### 笔记

+ 深搜+连通块的题目  岛屿会不会被淹没是这一块内的#号数量和 .相邻#号的数量是不是一致的
+ 每一次 bfs的时候就会创建一个块，然后bfs内部吧这个块相连的# 号全部加入到一起

### 第九题：乘积最大

#### 问题

给定N个整数A1, A2, ... AN。请你从中选出K个数，使其乘积最大。  

请你求出最大的乘积，由于乘积可能超出整型范围，你只需输出乘积除以1000000009的余数。  

注意，如果X<0， 我们定义X除以1000000009的余数是负(-X)除以1000000009的余数。
即：0-((0-x) % 1000000009)

【输入格式】
第一行包含两个整数N和K。  
以下N行每行一个整数Ai。  

对于40%的数据，1 <= K <= N <= 100  
对于60%的数据，1 <= K <= 1000  
对于100%的数据，1 <= K <= N <= 100000  -100000 <= Ai <= 100000  

【输出格式】
一个整数，表示答案。


【输入样例】
5 3 
-100000   
-10000   
2   
100000  
10000  

【输出样例】
999100009

再例如：
【输入样例】
5 3 
-100000   
-100000   
-2   
-100000  
-100000

【输出样例】
-999999829

#### 代码

```c++

```

#### 笔记
