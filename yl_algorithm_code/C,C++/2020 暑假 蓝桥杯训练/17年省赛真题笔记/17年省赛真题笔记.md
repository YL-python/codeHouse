#  17年省赛真题笔记

### 第一题：购物单

#### 问题

标题： 购物单

小明刚刚找到工作，老板人很好，只是老板夫人很爱购物。老板忙的时候经常让小明帮忙到商场代为购物。小明很厌烦，但又不好推辞。

这不，XX大促销又来了！老板夫人开出了长长的购物单，都是有打折优惠的。
小明也有个怪癖，不到万不得已，从不刷卡，直接现金搞定。
现在小明很心烦，请你帮他计算一下，需要从取款机上取多少现金，才能搞定这次购物。

取款机只能提供100元面额的纸币。小明想尽可能少取些现金，够用就行了。
你的任务是计算出，小明最少需要取多少现金。

#### 代码

```c++

```

#### 笔记

用excel 数据分列 简单函数计算

### 第二题：等差素数列

#### 问题

2,3,5,7,11,13,....是素数序列。
类似：7,37,67,97,127,157 这样完全由素数组成的等差数列，叫等差素数数列。
上边的数列公差为30，长度为6。

2004年，格林与华人陶哲轩合作证明了：存在任意长度的素数等差数列。
这是数论领域一项惊人的成果！

有这一理论为基础，请你借助手中的计算机，满怀信心地搜索：

长度为10的等差素数列，其公差最小值是多少？

#### 代码

```c++
#include <cstdio>
typedef long long LL;
const int N = 5000;

bool isPrime(LL x) {
	bool ans = true;
	for(LL i=2; i*i<x; i++) {
		if( x % i == 0) {
			ans = false;
		}
	}
	return ans;
}

LL fun(LL a[], int n) {
	for(int i=0; i<n; i++) {// 枚举素数数组
		for(int d=1; d<n; d++) {// 枚举公差
			LL first = a[i];
			int cnt=1;
			for(int j=1; j<=9; j++) { // 枚举10个
				LL ax = first + d*j;
				if(isPrime(ax)) {
					cnt++;
				} else {
					break;
				}
			}
			if(cnt == 10) {
				return d;
			}
		}
	}
	return -1;
}

int main() {
	LL a[N];
	a[0] = 2;
	a[1] = 3;
	a[2] = 5;
	LL t = 6;
	LL index = 3;
	while(index < N) {
		if(isPrime(t)) {
			a[index ++] = t;
		}
		t++;
	}
	printf("%d \n",fun(a,N));
	return 0;
}
```

#### 笔记

+ 填空题 直接暴力 不要花里胡哨的想许多，可能还浪费时间
+ 暴力枚举素数数组，暴力枚举公差，枚举10个出来就行

### 第三题：承压计算

#### 问题

X星球的高科技实验室中整齐地堆放着某批珍贵金属原料。

每块金属原料的外形、尺寸完全一致，但重量不同。
金属材料被严格地堆放成金字塔形。

```c
                             7 
                            5 8 
                           7 8 8 
                          9 2 7 2 
                         8 1 4 9 1 
                        8 1 8 8 4 1 
                       7 9 6 1 4 5 4 
                      5 6 5 5 6 9 5 6 
                     5 5 4 7 9 3 5 5 1 
                    7 5 7 9 7 4 7 3 3 1 
                   4 6 4 5 5 8 8 3 2 4 3 
                  1 1 3 3 1 6 6 5 5 4 4 2 
                 9 9 9 2 1 9 1 9 2 9 5 7 9 
                4 3 3 7 7 9 3 6 1 3 8 8 3 7 
               3 6 8 1 5 3 9 5 8 3 8 1 8 3 3 
              8 3 2 3 3 5 5 8 5 4 2 8 6 7 6 9 
             8 1 8 1 8 4 6 2 2 1 7 9 4 2 3 3 4 
            2 8 4 2 2 9 9 2 8 3 4 9 6 3 9 4 6 9 
           7 9 7 4 9 7 6 6 2 8 9 4 1 8 1 7 2 1 6 
          9 2 8 6 4 2 7 9 5 4 1 2 5 1 7 3 9 8 3 3 
         5 2 1 6 7 9 3 2 8 9 5 5 6 6 6 2 1 8 7 9 9 
        6 7 1 8 8 7 5 3 6 5 4 7 3 4 6 7 8 1 3 2 7 4 
       2 2 6 3 5 3 4 9 2 4 5 7 6 6 3 2 7 2 4 8 5 5 4 
      7 4 4 5 8 3 3 8 1 8 6 3 2 1 6 2 6 4 6 3 8 2 9 6 
     1 2 4 1 3 3 5 3 4 9 6 3 8 6 5 9 1 5 3 2 6 8 8 5 3 
    2 2 7 9 3 3 2 8 6 9 8 4 4 9 5 8 2 6 3 4 8 4 9 3 8 8 
   7 7 7 9 7 5 2 7 9 2 5 1 9 2 6 5 3 9 3 5 7 3 5 4 2 8 9 
  7 7 6 6 8 7 5 5 8 2 4 7 7 4 7 2 6 9 2 1 8 2 9 8 5 7 3 6 
 5 9 4 5 5 7 5 5 6 3 5 3 9 5 8 9 5 4 1 2 6 1 4 3 5 3 2 4 1 
X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X 
```

其中的数字代表金属块的重量（计量单位较大）。
最下一层的X代表30台极高精度的电子秤。

假设每块原料的重量都十分精确地平均落在下方的两个金属块上，
最后，所有的金属块的重量都严格精确地平分落在最底层的电子秤上。
电子秤的计量单位很小，所以显示的数字很大。

工作人员发现，其中读数最小的电子秤的示数为：2086458231

请你推算出：读数最大的电子秤的示数为多少？

注意：需要提交的是一个整数，不要填写任何多余的内容。

#### 代码

```c++
#include <cstdio>
#include <algorithm>
using namespace std;
typedef long long LL;
// 防止精度丢失  2的30次方就绝对不会出现精度丢失
const LL factor = 1073741824;

LL a[35][35];

int main() {
	for(int i =0; i<29; i++) {
		for(int j =0; j<=i; j++) {
			scanf("%lld",&a[i][j]);
			a[i][j] *= factor;
		}
	}
	for(int i =0; i<29; i++) {
		for(int j =0; j<=i; j++) {
			LL temp = a[i][j] / 2;
			a[i+1][j] += temp;
			a[i+1][j+1] += temp;
		}
	}
	sort(a[29],a[29]+30);
	printf("\n%lld ---%lld\n",a[29][0],a[29][29]);
	printf("\n%lld\n",a[29][29]/a[29][0]*2086458231);
	return 0;
}
```

#### 笔记

+ 用double回精度丢失所以一开始乘一个很大的数保证精度

### 第四题：方格分割

#### 问题

![](17%E5%B9%B4%E7%9C%81%E8%B5%9B%E7%9C%9F%E9%A2%98%E7%AC%94%E8%AE%B0.assets/p1.png)

![](17%E5%B9%B4%E7%9C%81%E8%B5%9B%E7%9C%9F%E9%A2%98%E7%AC%94%E8%AE%B0.assets/p2.png)

<img src="17%E5%B9%B4%E7%9C%81%E8%B5%9B%E7%9C%9F%E9%A2%98%E7%AC%94%E8%AE%B0.assets/p3.png" style="zoom:75%;" />

6x6的方格，沿着格子的边线剪开成两部分。
要求这两部分的形状完全相同。

请填写这个最多测试次数。

试计算：
包括这3种分法在内，一共有多少种不同的分割方法。
注意：旋转对称的属于同一种分割法。

#### 代码

```c++
#include <cstdio>
int ans,vis[7][7];
int dx[4] = {0,0,1,-1};
int dy[4] = {1,-1,0,0};

void dfs(int x,int y) {
	if(x == 0 || x== 6 || y == 0 || y == 6) {
		ans++;
		return ;
	}
	vis[x][y] = 1;  //当前点和对称点标记为访问
	vis[6-x][6-y] = 1;
	for(int i=-0; i<4; i++) {
		int tx = x + dx[i];
		int ty = y + dy[i];
		if(tx >=0 && tx <=6 && ty >=0 && ty <=6 && vis[tx][ty] == 0) {
			dfs(tx,ty);
		}
	}
	vis[x][y] = 0;
	vis[6-x][6-y] = 0;
}

int main() {
	dfs(3,3);
	printf("ans=%d\n",ans/4);
	return 0;
}
```

#### 笔记

+ 又要对称又要联通，可以看成是从中间点开始向四周扩散，看看有多少种情况
+ 有旋转算一种所以最后结果要除4

### 第五题：取数位

#### 问题

求1个整数的第k位数字有很多种方法。
以下的方法就是一种。

```c++
// 求x用10进制表示时的数位长度 
int len(int x){
	if(x<10) return 1;
	return len(x/10)+1;
}
	
// 取x的第k位数字
int f(int x, int k){
	if(len(x)-k==0) return x%10;
	return _____________________;  //填空
    // 答案是 f(x/10,k)
}
	
int main()
{
	int x = 23574;
	printf("%d\n", f(x,3));
	return 0;
}
```

对于题目中的测试数据，应该打印5。

请仔细分析源码，并补充划线部分所缺少的代码。

#### 笔记

+ 还是比较简单的 ，看懂了就能写出来了

### 第六题：最大公共子串

#### 问题

最大公共子串长度问题就是：
求两个串的所有子串中能够匹配上的最大长度是多少。

比如："abcdkkk" 和 "baabcdadabc"，
可以找到的最长的公共子串是"abcd",所以最大公共子串长度为4。

下面的程序是采用矩阵法进行求解的，这对串的规模不大的情况还是比较有效的解法。

请分析该解法的思路，并补全划线部分缺失的代码。

```c++
#include <stdio.h>
#include <string.h>

#define N 256
int f(const char* s1, const char* s2)
{
	int a[N][N];
	int len1 = strlen(s1);
	int len2 = strlen(s2);
	int i,j;
	
	memset(a,0,sizeof(int)*N*N);
	int max = 0;
	for(i=1; i<=len1; i++){
		for(j=1; j<=len2; j++){
			if(s1[i-1]==s2[j-1]) {
				a[i][j] = __________________________;  //填空
                // 答案是 a[i-1][j-1] + 1;
				if(a[i][j] > max) max = a[i][j];
			}
		}
	}
	
	return max;
}

int main()
{
	printf("%d\n", f("abcdkkk", "baabcdadabc"));
	return 0;
}
```

#### 笔记

+ 直接暴力查找，看一下就发现和 动态规划的代码很像，

### 第七题：日期问题

#### 问题

小明正在整理一批历史文献。这些历史文献中出现了很多日期。小明知道这些日期都在1960年1月1日至2059年12月31日。令小明头疼的是，这些日期采用的格式非常不统一，有采用年/月/日的，有采用月/日/年的，还有采用日/月/年的。更加麻烦的是，年份也都省略了前两位，使得文献上的一个日期，存在很多可能的日期与其对应。  

比如02/03/04，可能是2002年03月04日、2004年02月03日或2004年03月02日。  

给出一个文献上的日期，你能帮助小明判断有哪些可能的日期对其对应吗？

输入

一个日期，格式是"AA/BB/CC"。  (0 <= A, B, C <= 9)  

输入

输出若干个不相同的日期，每个日期一行，格式是"yyyy-MM-dd"。多个日期按从早到晚排列。  

样例输入

02/03/04  

样例输出

2002-03-04  
2004-02-03  
2004-03-02  

#### 代码

```c++
#include <iostream>
#include <set>
#include <sstream>
using namespace std;
int a,b,c;

int isLeap(int year) {
	if( (year%400 == 0) || (year%4==0&&year%100!=0) ) {
		return 1;
	} else {
		return 0;
	}
}

void i2s(int i,string &s) {
	stringstream ss;
	ss << i;
	ss >> s;
}

string fun(int a,int b,int c) {
	if(a >= 0 && a <= 59) {
		a+=2000;
	} else if(a > 59 && a < 100) {
		a+=1900;
	} else {
		return "";
	}
	if(b <1 || b>12) return "";
	if(c <1 || c>31) return "";
	int temp = 28 + isLeap(b);
	switch(b) {
		case 2:
			if(c>temp ) return "";
			break;
		case 4:
		case 6:
		case 9:
		case 11:
			if(c > 30) return "";
	}
	string _a,_b,_c;
	i2s(a,_a);
	i2s(b,_b);
	i2s(c,_c);
	if(_b.length() == 1) _b="0" + _b;
	if(_c.length() == 1) _c="0" + _c;
	return _a + "-" + _b + "-" + _c;
}
int main() {
	string s;
	cin >> s;
	a = (s[0] - '0')*10 + s[1] - '0';
	b = (s[3] - '0')*10 + s[4] - '0';
	c = (s[6] - '0')*10 + s[7] - '0';
	string s1 = fun(a,b,c);
	string s2 = fun(b,c,a);
	string s3 = fun(c,b,a);
	set<string> ans;
	if(s1 != "")ans.insert(s1);
	if(s2 != "")ans.insert(s2);
	if(s3 != "")ans.insert(s3);
	for(set<string>::iterator i=ans.begin(); i!=ans.end(); i++) {
		cout << *i << endl;
	}
	return 0;
}
```

#### 笔记

+ 排序去重用set是最香的
+ 注意 i2s()函数的编写和 set的遍历

### 第八题：包子凑数

#### 问题

小明几乎每天早晨都会在一家包子铺吃早餐。他发现这家包子铺有N种蒸笼，其中第i种蒸笼恰好能放Ai个包子。每种蒸笼都有非常多笼，可以认为是无限笼。

每当有顾客想买X个包子，卖包子的大叔就会迅速选出若干笼包子来，使得这若干笼中恰好一共有X个包子。比如一共有3种蒸笼，分别能放3、4和5个包子。当顾客想买11个包子时，大叔就会选2笼3个的再加1笼5个的（也可能选出1笼3个的再加2笼4个的）。

当然有时包子大叔无论如何也凑不出顾客想买的数量。比如一共有3种蒸笼，分别能放4、5和6个包子。而顾客想买7个包子时，大叔就凑不出来了。

小明想知道一共有多少种数目是包子大叔凑不出来的。

输入

第一行包含一个整数N。(1 <= N <= 100)
以下N行每行包含一个整数Ai。(1 <= Ai <= 100)  

输出

一个整数代表答案。如果凑不出的数目有无限多个，输出INF。

例如，
输入：
2  
4  
5   

程序应该输出：
6  

再例如，
输入：
2  
4  
6    

程序应该输出：
INF

样例解释：
对于样例1，凑不出的数目包括：1, 2, 3, 6, 7, 11。  
对于样例2，所有奇数都凑不出来，所以有无限多个。  

#### 代码

```c++
#include <cstdio>
int n,a[105],g;
bool f[10000];
int gcd(int a,int b) {
	return b?gcd(b,a%b):a;
}
int main() {
	f[0] = true;
	scanf("%d",&n);
	for(int i=1; i<=n; i++) {
		scanf("%d",&a[i]);
		if(i == 1) g = a[i];
		else g = gcd(a[i],g);
		for(int j=0; j<10000; j++) {
			if(f[j]) f[j + a[i]] = true;
		}
	}
	if(g != 1) {
		printf("INF\n");
		return 0;
	}
	// 统计个数
	int ans =0;
	for(int I=0; I<10000; I++) {
		if(! f[I])ans++;
	}
	printf("%d\n",ans);
	return 0;
}
```

#### 笔记

+ 凑数问题
+ 如果两个数不是互质数，那么就不会凑出所有数。
+ 如果两个数是互质数，那么这两个数不能凑出的数的最大值是 a*b-a-b
+ 打表的时候考虑完全背包问题

### 第九题：分巧克力

#### 问题

儿童节那天有K位小朋友到小明家做客。小明拿出了珍藏的巧克力招待小朋友们。
小明一共有N块巧克力，其中第i块是Hi x Wi的方格组成的长方形。

为了公平起见，小明需要从这 N 块巧克力中切出K块巧克力分给小朋友们。切出的巧克力需要满足：

1. 形状是正方形，边长是整数  
2. 大小相同  

例如一块6x5的巧克力可以切出6块2x2的巧克力或者2块3x3的巧克力。

当然小朋友们都希望得到的巧克力尽可能大，你能帮小Hi计算出最大的边长是多少么？

输入
第一行包含两个整数N和K。(1 <= N, K <= 100000)  
以下N行每行包含两个整数Hi和Wi。(1 <= Hi, Wi <= 100000) 
输入保证每位小朋友至少能获得一块1x1的巧克力。   

输出
输出切出的正方形巧克力最大可能的边长。

样例输入：
2 10  
6 5  
5 6  

样例输出：
2

#### 代码

```c++
#include <iostream>
using namespace std;

int main() {
	int n,k;
	int h[100000],w[100000];
	cin >> n >> k;
	for(int i=0; i<n; i++) {
		cin >> h[i] >> w[i];
	}
	int r = 100001;
	int l = 1;
	int ans;
	while(l <= r) {
		int mid = (l+r) / 2;
		int cnt = 0;
		for(int i=0; i<n; i++) {
			cnt += (h[i] / mid) * (w[i] / mid)
		}
		if(cnt > mid) {
			l = mid + 1;
			ans = mid;
		} else {
			r = mid - 1;
		}
	}
	printf("%d",ans);
	return 0;
}
```

#### 笔记

+ 题目不难 暴力枚举就会超时
+ 观察发现是 1  0 序列，可以用二分来做；

### 第十题：k倍区间

#### 问题

给定一个长度为N的数列，A1, A2, ... AN，如果其中一段连续的子序列Ai, Ai+1, ... Aj(i <= j)之和是K的倍数，我们就称这个区间[i, j]是K倍区间。  

你能求出数列中总共有多少个K倍区间吗？  

输入

第一行包含两个整数N和K。(1 <= N, K <= 100000)  
以下N行每行包含一个整数Ai。(1 <= Ai <= 100000)  

输出

输出一个整数，代表K倍区间的数目。  

例如，
输入：
5 2
1  
2  
3  
4  
5  

程序应该输出：
6

#### 代码

```c++
#include <iostream>
#include <map>
using namespace std;

int n,k,a[100005],s[100005];
map<int,int> cnt; // 同余数的统计

int main() {
	cin >> n >> k;
	s[0] = 0;
	cnt[0] = 1;
	for(int i=1; i<=n; i++) {
		cin >> a[i];
		s[i] = (s[i-1] + a[i]) % k;  // 前缀和的同余序列 
		cnt[s[i]] ++;
	}
	long long ans = 0;
//	for(int i=1; i<=n; i++) {
//		for(int j=i; j<=n; j++) {
//			if(s[j] - s[i-1] % k == 0) {
//				ans++;
//			}
//		}
//	}
	for(int i=0; i<k; i++) {  // 余数必然在 0~k-1之间
		ans += (long long) cnt[i] * (cnt[i] - 1) / 2;  // 任意取2个 排列组合是Ci2
	}
	cout << ans << endl;
	return 0;
}
```

#### 笔记

+ 前缀和的暴力枚举还是回超时
+ 前缀和的同余序列中，任意两个相等的值做差，结果肯定还是0
+ 枚举余数个数就行了，在前缀和的同余序列 中相等的两个数来做差，余这个数肯定还是 0 

