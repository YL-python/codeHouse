<!DOCTYPE html>
<html lang="zh-CN">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>

<body>
  <script>
    // 1.函数模式: this 表示全局对象( 浏览器中是window, 在 node 中是 global )
    // 特点：独立运行，调用的语法前没有任何的引导数据
    function fun1() {
      console.log('函数模式：', this);
    }
    // 函数调用的前面 不能有  '通过 xxx 得到 函数名' 这个行为
    fun1()  // 等价于 window.fun1()
    

    // 2.构造器模式：this 表示刚刚创建出来的对象
    // 构造器 语法 ：new 构造函数()
    function Person() { console.log('构造器模式：',this); }
    var p = new Person();
    /*
    执行过程分析
      1. 使用 new 运算符 分配内存空间，在js中就是创建了一个对象（是一个空对象，具有原型结构）
        空对象就是表示没有任何 自己的成员
        具有 原型结构，比如上面的对象的原型就是 Person.prototype
      2. 调用构造函数
        创建 活动对象
        刚刚创建出来的对象（活动对象） 使用this 来引用上下文对象
        预解析
        解释执行
        ... 这里解释这几步
    */
    

    // 3. 方法调用模式: this 表示引导方法调用的对象
    // 一个函数作为一个对象的成员，由对象引导调用，就是方法调用
    // 表现就是 调用前有一个引导数据，满足：通过 xxx 范围到方法名进行调用
    var o1={
      sayHello:function(){console.log('方法调用模式:',this);}
    }
    o1.sayHello()

    function fun2(){console.log('fun2 方法：',this);}
    var o2={name:'o2'}
    o2.fun2 = fun2;
    console.log("o2.fun2() === fun2() ==>", o2.fun2 === fun2);  // 地址完全相同
    o2.fun2();
    fun2()

    var arr=[]
    arr.push(func2)
    var fn = arr[0];
    fun();  // 函数调用 没有引导对象
    arr[0]();  // 方法调用 引导对象是 arr 
    



  </script>
</body>

</html>