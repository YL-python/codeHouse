# 变换莫测的 this

目标:

1. 能分析 this 的实际意义
2. 常用 技巧

## 1. 作用域链

- 函数在执行的时候会形成一个 "函数调用栈"
- 函数的定义与函数的运行的内存关系
  - js 在 v8 中虽然有编译型语言的特征, 但是它依旧是解释性语言
    - js 的函数是惰性执行
    - 如果 函数不被调用, 其不会再内存中创建任何东西
      - js 中函数在执行的时候 js 引擎会给函数分配内存
      - js 中的函数如果不执行, 那么 js 引擎就会忽略他, 不分配任何内存
  - js 的函数在执行之前不会分配内存
  - js 中的函数在执行的时候会分配内存
  - js 中的函数执行完成以后, 若内存中的数据不被再引用, 则这段内存会被 js 引擎回收掉

js 函数在运行的时候 ( ing ), 会有一个与之相关的内存被申请处理

问题:

1. 一个函数如果被连续的调用两次, 那么会分配几个内存? 它会分配两段内存, 其内存是没有关系.
2. 这个内存中是用来干什么呢? 这个内存被称为 活动对象 ( active object )
  这个活动对象中存储的就是函数的参数, 与函数内定义的变量等.

图示

变量的搜索原则

1. 由于一个活动对象中可以有多个数据( 标识符 ), 我们将其抽象的想象成一排盒子
2. 多个活动对象是有一个链接关系, 由于一个复杂的代码结构移动存在很多活动对象链接起来, 那么可以形成一个链式结构, 常常将所有的活动对象的整体称为 "作用域链"
3. 变量搜索原则
   1. 凡是需要访问某一个变量, 首先会在当前作用域( 活动对象 )上去查找是否存在该变量
   2. 如果存在, 则使用该变量
   3. 若不存在, 则进入到上一级作用域 ( 也就是与之相关联的上一个活动对象 )来查找.
   4. 若在上一级作用域查找到了, 则直接使用
   5. 若依旧没有, 则继续向上一级作用域查找
   6. ....
   7. 总会找到全局作用域 ( 全局活动对象 ), 若全局也没有 则会 抛出一个错误
      xxxx is not defined



## 2. eval 与 Function

语法: 

```js
eval( '代码字符串' )

var  func = new Function( '参数1', '参数2', ..., '参数N', '函数体' );
fucn();
```

1. eval 在执行代码的时候, 代码所处的作用域为当前作用域
2. 如果 eval 被引用后执行代码, 那么代码所处的作用域为全局作用域
3. Function 都是在全局作用域下 



## 3. 函数的调用模式

- 函数模式
- 构造器模式
- 方法模式
- 上下文模式
- bind 模式

## 4. 箭头函数


## 5. 面试题

```js
var length = 10;
function fn() {
  console.log( this.length );
}

var obj = {
  length: 5,
  method: function ( fn ) {
    fn();
    arguments[ 0 ]();
  }
};
obj.method( fn, 1, 2, 3 );
```

