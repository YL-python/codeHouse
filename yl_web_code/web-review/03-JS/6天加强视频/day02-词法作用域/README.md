# 神秘的词法作用域

目标:

1. 能口述 JS 代码的执行流程
2. 能口述函数调用栈, 词法作用域和闭包的关系

## 1. JS 是怎么执行的

- JS 代码执行模型
  - 线性执行: 一次只做一件事情, 一件一件排队完成
  - 函数调用栈:
    - 实际上在 js 的执行中, 将全局的代码结构可以看成一个 大的函数
    - 每次执行函数, 就相当于调用一个函数, 会创建一个该函数独有的作用空间
    - 函数还可以继续调用函数, 这个函数独有的存储空间就会不断的被创建
    - 函数执行结束这个独有的内存结构就会被释放
  - 事件队列
    - 事件机制与异步延时机制的本质( 第六次课程 )

- JS 的执行步骤
  我们的浏览器在 打开之后 JS 是怎么执行的
  或
  使用 node 来运行 js 是怎么执行

  运行平台 

  1. 读取所有的 js 代码文件( 文本文件 )
  2. 会对该文件进行 "编译" ( 将其理解为 源代码 -> 抽象语法树 -> 字节码( 伪汇编 ) )
  3. 运行时将其转换为机器码 ( 不同平台 得到 机器码就不一样了 ) 
  4. 运行


  传统的编译型编程语言( 简化 ): 
    文本文件 -> 抽象的语法树 -> 借助于优化器 得到 中间 代码 
    -> 借助编译器编程 二进制代码 -> 借助连接器 转换成二进制可执行文件


## 2. 词法作用域

函数的声明一定是形如

// 前面也不允许有代码与函数的代码结合
function 函数名 ( ... ) {

} // 后面不允许有其他的代码与函数的代码结合

var f = function f() {};

!function f() {}


- js 的运行时有一个过程的, 简单的可以将其分为 
  1. 预编译过程
     - 在准备执行之前 缓存 中需要的东西, 编译器, 运行时需要的东西
     - js 引擎会读取 每一个 js 代码, 并将其记录在 内部的缓存中
     - 这里我们重点考虑 声明 ( 变量的声明, 函数的声明 )
     - 处理步骤
       1. 从上往下 "阅读" 代码   
       2. 看到 var 变量的声明, 或 let 变量的声明, 或 function 函数声明 则将其记录下
          1. var 变量的声明 会在缓存中 记录 变量的 名字, 其值为 未初始化 undefined
          2. 如果看到 var 的变量名 与 已经记录的名字重名 则覆盖
          3. let 变量的声明 也会在缓存中记录变量的名字, js 引擎会在记录 该名字后 创造一个 暂时性假死的区域 ( 这个名字是不能用 )
          4. 如果在 let 之前 有过同名的 名字 被记录了, 或其后 var 声明同样的名字是不被允许.
          5. 如果看到的是函数的声明, 分为两个步骤
             1. 会将函数的名字 作为 名字 记录到 缓存中 ( 这一点与 var 声明一样 )
             2. 会将这个名字与函数体进行关联

  2. 执行过程 
     - 解释执行, 解释一句, 执行一句


- 什么是作用域链
- 什么是变量搜索原则


### 常见面试题

```js
if ( 'a' in window ) {
  var a = 123;
}

console.log( a );
```

理性的分析:

1. js 引擎会读取这段代码, 然后
   1. 读取到 第 二行的时候 ( var a = 123 ) 发现有一个变量的声明
   2. 将改变量记录到 缓存中 ( js 引擎运行时的缓存 )
   3. 变量的值为 undefined
2. 开始执行阶段: 一句一句的解释执行
    开始解释: 'a' in window 
    开始执行 赋值
    打印结果


in 是运算符 语法: 
  '名字' in 对象
  看这个名字 表示的属性是否存在于 对象中


```js
var num = 123;

function num () {
  console.log( 'Hello js' );
}

console.log( num ); 
```

1. pre 阶段
   1. 读取代码
      1. 第一行 var num = 123; 将 num 这个名字 记录在 js 引擎的缓存中
      2. 在 第三行 到 第五行 读取到函数的声明
         1. 将名字 记录到缓存中, 缓存中已有改名字 覆盖( 无效果 )
         2. 将名字与函数体关联
2. run 阶段
   1. 执行赋值 将 123 赋值给 num, 注意此时函数体没了
   2. 执行输出 num 的值: 123
